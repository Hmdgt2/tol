# LISTA DE FUNÇÕES DA BIBLIOTECA
# Gerado em: 2025-10-13 17:27:10
==================================================

## ESTATÍSTICAS GERAIS
- Funções únicas: 463
- Categorias: 53
- Duplicados: 2

## CATEGORIA: ALGEBRA_CATEGORIAS (4 funções)
- monoid_operation_check(elements, operation)
  # Verifica se um conjunto com operação forma um monóide
- functor_application(functions, objects)
  # Aplica uma lista de funções como um funtor
- natural_transformation(functor1, functor2, objects)
  # Transformação natural entre dois functores
- yoneda_embedding(objects, hom_functor)
  # Embedding de Yoneda simplificado

## CATEGORIA: ALGEBRA_LINEAR (15 funções)
- matrix_determinant(mat)
  # Calcula o determinante de uma matriz
- matrix_rank(mat)
  # Calcula o posto de uma matriz
- matrix_inverse(mat)
  # Calcula a inversa de uma matriz
- matrix_trace(mat)
  # Calcula o traço de uma matriz
- matrix_condition_number(mat)
  # Calcula o número de condição de uma matriz
- matrix_norm_fro(mat)
  # Calcula a norma de Frobenius de uma matriz
- matrix_norm_inf(mat)
  # Calcula a norma do infinito de uma matriz
- matrix_eigenvalues(mat)
  # Calcula os autovalores de uma matriz
- matrix_eigenvectors(mat)
  # Calcula os autovetores de uma matriz
- solve_linear_system(A, b)
  # Resolve um sistema de equações lineares Ax=b
- cholesky_decomposition(mat)
  # Realiza a decomposição de Cholesky
- qr_decomposition(mat)
  # Realiza a decomposição QR
- svd_u(mat)
  # Retorna a matriz U da SVD
- svd_s(mat)
  # Retorna os valores singulares da SVD
- matrix_pinv(mat)
  # Calcula a pseudoinversa de uma matriz

## CATEGORIA: ALGEBRA_SIMBOLICA (8 funções)
- sym_derivative(expr)
  # Calcula a derivada de uma expressão simbólica
- sym_integral(expr)
  # Calcula a integral indefinida de uma expressão simbólica
- sym_series_expansion(expr, n)
  # Expande uma expressão em série de Taylor em torno de 0
- sym_limit(expr, point)
  # Calcula o limite de uma expressão no ponto dado
- sym_roots(expr)
  # Encontra as raízes de uma expressão
- sym_simplify(expr)
  # Simplifica uma expressão
- sym_expand(expr)
  # Expande uma expressão
- sym_factor(expr)
  # Fatora uma expressão

## CATEGORIA: ALGORITMOS_GRAFOS (5 funções)
- dijkstra_path(G, source, target, weight)
  # Encontra o caminho mais curto entre origem e destino (Dijkstra)
- dijkstra_length(G, source, target, weight)
  # Calcula o comprimento do caminho mais curto entre origem e destino (Dijkstra)
- shortest_path_all_pairs(G)
  # Encontra o comprimento do caminho mais curto entre todos os pares de nós
- is_connected(G)
  # Verifica se o grafo é conexo
- has_cycle(G)
  # Verifica se o grafo contém pelo menos um ciclo

## CATEGORIA: ANALISE_FUNCIONAL (3 funções)
- sobolev_norm(f, domain, order, p)
  # Norma de Sobolev W^{k,p} aproximada
- operator_norm_approx(operator, basis, domain)
  # Norma de operador aproximada
- spectral_radius_approx(operator, iterations)
  # Raio espectral aproximado de um operador

## CATEGORIA: ANALISE_NUMERICA (5 funções)
- laplace_transform(f, a)
  # Calcula a transformada de Laplace de uma função
- z_transform(lst)
  # Calcula a transformada Z de uma sequência discreta
- airy_func(x)
  # Calcula a função Airy
- product_primes(lst)
  # Calcula o produto dos números primos numa lista
- product_prime_gaps(lst)
  # Calcula o produto dos gaps entre primos numa lista

## CATEGORIA: ANALISE_NUMERICA_AVANCADA (14 funções)
- mellin_transform(f, s)
  # Transformada de Mellin de uma função
- hankel_transform(f, k, order)
  # Transformada de Hankel de ordem n
- fourier_bessel_transform(seq)
  # Transformada Fourier-Bessel para sequências
- hypergeometric_1f1(a, b, z)
  # Função hipergeométrica confluente ₁F₁(a;b;z)
- hypergeometric_2f1(a, b, c, z)
  # Função hipergeométrica Gaussiana ₂F₁(a,b;c;z)
- meijer_g_transform(params, z)
  # Função G de Meijer simplificada
- fresnel_integral(x)
  # Integrais de Fresnel C(x) e S(x)
- exponential_integral_e1(z)
  # Integral exponencial E₁(z)
- sine_integral(x)
  # Integral seno Si(x)
- cosine_integral(x)
  # Integral cosseno Ci(x)
- mathieu_characteristic(a, q, n)
  # Coeficiente característico de Mathieu
- mathieu_function_even(t, a, q)
  # Função de Mathieu par
- lyapunov_exponent(seq)
  # Expoente de Lyapunov para sequências
- takens_embedding(seq, dimension, delay)
  # Embedding de Takens para reconstrução de espaço de estados

## CATEGORIA: ANALISE_PADROES (10 funções)
- sum_of_pairs(lst)
  # Calcula a soma de todas as combinações de pares
- sum_of_triples(lst)
  # Calcula a soma de todas as combinações de trios
- diff_of_pairs(lst)
  # Calcula a diferença absoluta de todos os pares
- count_pair_sums_equal(lst, value)
  # Conta os pares cuja soma é igual a um valor
- score_even_odd(lst)
  # Pontua a lista com base na paridade dos elementos
- score_prime(lst)
  # Pontua a lista com base na presença de números primos
- score_pairs_sum_mod(lst, k)
  # Pontua a lista com base na soma dos pares módulo k
- score_cumulative_diff(lst)
  # Pontua a lista com base na soma das diferenças absolutas consecutivas
- most_frequent_pairs(lst)
  # Encontra os pares mais frequentes na lista
- cluster_by_diff(lst, max_diff)
  # Agrupa números que estão próximos uns dos outros

## CATEGORIA: ANALISE_PRIMOS (17 funções)
- primes_in_list(lst)
  # Filtra e retorna os números primos de uma lista
- count_primes(lst)
  # Conta a quantidade de números primos em uma lista
- count_primes_below(lst, limit)
  # Conta os primos abaixo de um limite
- count_primes_above(lst, limit)
  # Conta os primos acima de um limite
- sum_primes(lst)
  # Calcula a soma dos números primos em uma lista
- mean_primes(lst)
  # Calcula a média dos números primos em uma lista
- median_primes(lst)
  # Calcula a mediana dos números primos em uma lista
- max_prime(lst)
  # Retorna o maior número primo em uma lista
- min_prime(lst)
  # Retorna o menor número primo em uma lista
- range_primes(lst)
  # Calcula a diferença entre o maior e o menor primo
- prime_near_mean(lst)
  # Retorna o número primo mais próximo da média da lista
- next_primes(lst)
  # Retorna o próximo número primo de cada elemento
- prime_gaps(lst)
  # Calcula os gaps (diferenças) entre números primos consecutivos
- sum_prime_gaps(lst)
  # Calcula a soma dos gaps entre números primos
- odd_primes(lst)
  # Retorna os números primos ímpares de uma lista
- square_primes(lst)
  # Retorna o quadrado de cada número primo em uma lista
- prime_binary(lst)
  # Cria uma representação binária (1=primo, 0=não primo)

## CATEGORIA: ARITMETICA (13 funções)
- add(a, b)
  # Calcula a soma de dois números
- sub(a, b)
  # Calcula a subtração de dois números
- mul(a, b)
  # Calcula a multiplicação de dois números
- div(a, b)
  # Calcula a divisão de dois números, evitando divisão por zero
- mod(a, b)
  # Calcula o resto da divisão de dois números, evitando divisão por zero
- pow_func(a, b)
  # Calcula a potência de um número
- sqrt(a)
  # Calcula a raiz quadrada de um número
- cbrt(a)
  # Calcula a raiz cúbica de um número
- log_func(a)
  # Calcula o logaritmo natural de um número, se for positivo
- exp_func(a)
  # Calcula o exponencial de um número
- neg(a)
  # Retorna o negativo de um número
- inv(a)
  # Calcula o inverso de um número, se não for zero
- abs_val(a)
  # Calcula o valor absoluto de um número

## CATEGORIA: COMBINATORIA (4 funções)
- factorial_func(a)
  # Calcula o fatorial de um número inteiro não negativo
- comb_func(n, k)
  # Calcula as combinações de n elementos em grupos de k
- perm_func(n, k)
  # Calcula as permutações de n elementos em grupos de k
- multinomial_coef(lst)
  # Calcula o coeficiente multinomial de uma lista de números

## CATEGORIA: COMBINATORIA_AVANCADA (23 funções)
- combinations_sum(lst, r)
  # Soma todas as combinações de r elementos da lista
- permutations_sum(lst, r)
  # Soma todas as permutações de r elementos da lista
- sum_combinations2(lst)
  # Soma de todas as combinações de 2 elementos
- sum_combinations3(lst)
  # Soma de todas as combinações de 3 elementos
- sum_permutations2(lst)
  # Soma de todas as permutações de 2 elementos
- prod_combinations2(lst)
  # Produto das somas de todas as combinações de 2 elementos
- prod_permutations2(lst)
  # Produto das somas de todas as permutações de 2 elementos
- max_diff_combinations(lst, k)
  # Diferença entre a soma máxima e mínima das combinações
- mean_combinations2(lst)
  # Média das somas de todas as combinações de 2 elementos
- reduce_sum(lst)
  # Soma de uma lista usando reduce
- reduce_prod(lst)
  # Produto de uma lista usando reduce
- reduce_max(lst)
  # Máximo de uma lista usando reduce
- prod_ratio(lst)
  # Produto das proporções entre elementos consecutivos
- conditional_permutations(lst, condition)
  # Permutações que satisfazem uma condição
- combinations_with_sum(lst, target)
  # Combinações cuja soma é igual ao valor alvo
- count_combinations_with_sum(lst, target)
  # Conta combinações cuja soma é igual ao valor alvo
- product_sum(lst1, lst2)
  # Soma dos pares do produto cartesiano de duas listas
- product_prod(lst1, lst2)
  # Produto dos pares do produto cartesiano de duas listas
- product_sum_square(lst1, lst2)
  # Quadrado da soma de cada par do produto cartesiano
- product_prod_square(lst1, lst2)
  # Quadrado do produto de cada par do produto cartesiano
- combination_count(n, k)
  # Número exato de combinações
- permutation_count(n, k)
  # Número exato de permutações
- factorial_list(lst)
  # Fatorial de cada elemento de uma lista

## CATEGORIA: COMBINATORIA_AVANCADA_1 (12 funções)
- multinomial_coefficient(params)
  # Coeficiente multinomial
- catalan_number(n)
  # Número de Catalan C_n
- stirling_first(n, k)
  # Números de Stirling de primeiro tipo s(n,k)
- stirling_second(n, k)
  # Números de Stirling de segundo tipo S(n,k)
- integer_partitions(n)
  # Gera todas as partições inteiras de n
- set_partitions_count(n, k)
  # Número de partições de conjunto de n elementos em k blocos
- young_tableaux_count(shape)
  # Número de tableaux de Young para uma dada forma
- derangements_count(n)
  # Número de desarranjos (permutações sem pontos fixos)
- involution_count(n)
  # Número de involuções (permutações que são suas próprias inversas)
- complete_graph_edges(n)
  # Número de arestas em grafo completo K_n
- tree_count(n)
  # Número de árvores rotuladas (Fórmula de Cayley)
- bipartite_graph_count(m, n)
  # Número de grafos bipartidos completos entre conjuntos de tamanhos m e n

## CATEGORIA: CRIPTOGRAFIA (3 funções)
- generate_key()
  # Gera uma chave de criptografia Fernet e armazena globalmente
- encrypt_data(data)
  # Criptografa dados usando a chave Fernet armazenada
- decrypt_data(token)
  # Descriptografa dados usando a chave Fernet armazenada

## CATEGORIA: DETECCAO_ANOMALIAS (2 funções)
- z_score_outliers(lst, threshold)
  # Detecta outliers usando o método de Z-score
- rolling_z_score(lst, window, threshold)
  # Detecta outliers usando um Z-score móvel

## CATEGORIA: ESTATISTICA_MULTIVARIADA (5 funções)
- covariance_matrix(X)
  # Calcula a matriz de covariância de um conjunto de dados
- correlation_matrix(X)
  # Calcula a matriz de correlação de um conjunto de dados
- silhouette(X, labels)
  # Calcula o coeficiente de silhueta para avaliar a qualidade de um agrupamento
- pca_eigenvalues(X)
  # Calcula os autovalores da matriz de covariância para a Análise de Componentes Principais (PCA)
- gini_index(values)
  # Calcula o índice de Gini para medir a desigualdade

## CATEGORIA: ESTATISTICA_MULTIVARIADA_2 (4 funções)
- mahalanobis_distance(X)
  # Distância de Mahalanobis para cada ponto
- hotelling_t2_test(X, Y)
  # Teste T² de Hotelling para duas amostras multivariadas
- canonical_correlation(X, Y)
  # Correlação canônica entre dois conjuntos de variáveis
- linear_discriminant_analysis(X, y)
  # Análise de Discriminante Linear simplificada

## CATEGORIA: ESTATISTICA_NAO_PARAMETRICA (7 funções)
- kendall_tau(x, y)
  # Calcula o coeficiente de correlação de Kendall
- spearman_corr(x, y)
  # Calcula o coeficiente de correlação de Spearman
- mann_whitney(x, y)
  # Realiza o teste de soma de postos de Mann-Whitney U
- kruskal_test()
  # Realiza o teste de Kruskal-Wallis H para múltiplos grupos
- wilcoxon_test(x, y)
  # Realiza o teste de soma de postos de Wilcoxon para amostras pareadas
- median_test(x, y)
  # Calcula a diferença entre as medianas de duas amostras
- range_stat(lst)
  # Calcula a amplitude (range) de uma amostra

## CATEGORIA: ESTATISTICAS (11 funções)
- unique_count(lst)
  # Conta o número de elementos únicos em uma lista
- intersection(lst1, lst2)
  # Retorna os elementos em comum entre duas listas
- union(lst1, lst2)
  # Retorna a união de elementos de duas listas
- difference(lst1, lst2)
  # Retorna os elementos de lst1 que não estão em lst2
- symmetric_difference(lst1, lst2)
  # Retorna os elementos que estão em lst1 ou lst2, mas não em ambos
- mirror_count(lst, total)
  # Conta os números que têm um 'espelho' na lista (e
- pair_sum_count(lst, target)
  # Conta os pares de números que somam um valor alvo
- pair_product_count(lst, target)
  # Conta os pares de números que multiplicados dão um valor alvo
- count_even(lst)
  # Conta números pares na lista
- count_odd(lst)
  # Conta números ímpares na lista
- iqr_outliers(lst)
  # Detecta outliers usando o método do Intervalo Interquartil (IQR)

## CATEGORIA: EXPLORACAO (2 funções)
- linear_trend_slope(lst)
  # Calcula a inclinação da tendência linear de uma lista
- successive_diff(lst)
  # Calcula a diferença entre elementos sucessivos

## CATEGORIA: FUNCOES_DIVERSAS (8 funções)
- convex_hull_area(points)
  # Área do convex hull de um conjunto de pontos
- smallest_enclosing_circle(points)
  # Círculo mínimo que engloba todos os pontos
- graph_spectral_gap(adjacency_matrix)
  # Gap espectral do grafo (diferença entre dois maiores autovalores)
- betweenness_centrality_approx(graph_edges, num_nodes, k)
  # Betweenness centrality aproximada usando amostragem
- simple_hash_function(data, mod)
  # Função hash simples para lista de inteiros
- linear_congruential_generator(seed, n, a, c, m)
  # Gerador congruencial linear para números pseudo-aleatórios
- jaccard_similarity(text1, text2)
  # Similaridade de Jaccard entre dois textos
- levenshtein_distance_ratio(s1, s2)
  # Razão de similaridade baseada na distância de Levenshtein

## CATEGORIA: FUNCOES_ESPECIAIS (11 funções)
- gamma_func(x)
  # Calcula a função Gamma
- beta_func(a, b)
  # Calcula a função Beta
- zeta_func(s)
  # Calcula a função Zeta de Riemann
- bessel_j(n, x)
  # Calcula a função de Bessel de primeira espécie
- legendre_poly(n, x)
  # Calcula o polinómio de Legendre
- chebyshev_T(n, x)
  # Calcula o polinómio de Chebyshev de primeira espécie
- chebyshev_U(n, x)
  # Calcula o polinómio de Chebyshev de segunda espécie
- hermite_poly(n, x)
  # Calcula o polinómio de Hermite
- laguerre_poly(n, x)
  # Calcula o polinómio de Laguerre
- discrete_convolution(lst1, lst2)
  # Calcula a convolução discreta de duas listas
- cross_correlation(lst1, lst2)
  # Calcula a correlação cruzada de duas listas

## CATEGORIA: GEOMETRIA (8 funções)
- euclidean_dist(a, b)
  # Calcula a distância euclidiana entre dois pontos
- manhattan_dist(a, b)
  # Calcula a distância de Manhattan entre dois pontos
- chebyshev_dist(a, b)
  # Calcula a distância de Chebyshev entre dois pontos
- cosine_dist(a, b)
  # Calcula a distância do cosseno entre dois vetores
- hamming_dist_str(a, b)
  # Calcula a distância de Hamming entre duas strings
- levenshtein_dist(a, b)
  # Calcula a distância de Levenshtein entre duas strings
- jaccard_index(a, b)
  # Calcula o índice de Jaccard entre dois conjuntos
- centroid(points)
  # Calcula o centroide de um conjunto de pontos

## CATEGORIA: GEOMETRIA_DIFERENCIAL (3 funções)
- gaussian_curvature(surface_points)
  # Curvatura gaussiana aproximada de uma superfície
- geodesic_distance(surface_func, point1, point2, steps)
  # Distância geodésica aproximada entre dois pontos em uma superfície
- riemann_metric_tensor(surface_func, u, v, eps)
  # Tensor métrico de Riemann em um ponto da superfície

## CATEGORIA: GEOMETRIA_FRACTAL (2 funções)
- multifractal_spectrum(points, q_values)
  # Espectro multifractal f(α)
- lacunarity_analysis(points, box_sizes)
  # Análise de lacunaridade para conjuntos fractais

## CATEGORIA: GRAFOS (23 funções)
- create_graph(lst)
  # Cria um grafo completo a partir de uma lista de nós
- num_nodes(lst)
  # Retorna o número de nós de um grafo criado a partir de uma lista
- num_edges(lst)
  # Retorna o número de arestas de um grafo completo
- node_degrees(lst)
  # Calcula os graus de cada nó em um grafo
- graph_degree(lst)
  # Calcula o grau (número de conexões) de cada nó no grafo
- graph_avg_degree(lst)
  # Calcula o grau médio de todos os nós do grafo
- mean_degree(lst)
  # Calcula o grau médio de um grafo
- std_degree(lst)
  # Calcula o desvio padrão dos graus de um grafo
- is_complete(lst)
  # Verifica se um grafo criado a partir da lista é completo
- graph_density(lst)
  # Calcula a densidade do grafo
- graph_diameter(lst)
  # Calcula o diâmetro do grafo (maior caminho mais curto)
- graph_connected_components_count(lst)
  # Conta o número de componentes conectados no grafo
- graph_connected_components(G)
  # Retorna os componentes conectados de um grafo
- graph_triangle_count(lst)
  # Conta o número de triângulos no grafo
- degree_centrality(lst)
  # Calcula a centralidade de grau de cada nó
- closeness_centrality_from_graph(G)
  # Calcula a centralidade de proximidade de um grafo existente
- closeness_centrality_from_list(lst)
  # Calcula a centralidade de proximidade de cada nó (grafo criado a partir da lista)
- betweenness_centrality(G)
  # Calcula a centralidade de intermediação de um grafo
- eigenvector_centrality(G)
  # Calcula a centralidade de autovetor de um grafo
- pagerank_scores(G, alpha)
  # Calcula os scores de PageRank de um grafo
- shortest_paths_length(G)
  # Calcula os comprimentos dos caminhos mais curtos entre todos os pares de nós
- graph_eigenvalues(G)
  # Calcula os autovalores da matriz de adjacência de um grafo
- graph_laplacian_spectrum(G)
  # Calcula o espectro Laplaciano de um grafo

## CATEGORIA: IA_HEURISTICA (20 funções)
- mutate_list(lst, mutation_rate, max_val)
  # Aplica mutação a uma lista, trocando elementos aleatoriamente
- crossover_lists(lst1, lst2)
  # Combina duas listas em um ponto de cruzamento
- fitness_sum(lst, target)
  # Calcula o 'fitness' de uma lista com base em sua soma
- fitness_even_ratio(lst, target_ratio)
  # Calcula o 'fitness' com base na proporção de números pares
- select_best_population(population, fitness_func, k)
  # Seleciona a melhor parte de uma população com base em uma função de fitness
- combined_score(lst, heuristics)
  # Combina o score de múltiplas heurísticas para uma lista
- weighted_score(lst, heuristics, weights)
  # Calcula o score combinado de heurísticas com pesos
- rank_heuristics(lst, heuristics)
  # Classifica heurísticas com base em seu desempenho em uma lista
- generate_heuristic_from_library(lst, funcs)
  # Executa uma heurística aleatória da biblioteca
- integrated_heuristic_test(lst, heuristics)
  # Testa e retorna heurísticas ordenadas por score
- top_k_integrated(lst, heuristics, k)
  # Retorna as top K heurísticas integradas
- generate_new_combined_heuristic(heuristics, transforms)
  # Gera uma nova heurística combinando uma função com uma transformação
- stochastic_score(lst, heuristics, trials)
  # Calcula o score estocástico de uma lista
- combined_stochastic_score(lst, heuristics, weights, trials)
  # Calcula o score estocástico combinado com pesos
- random_selection(lst, k)
  # Seleciona k elementos aleatórios de uma lista
- weighted_choice(lst, weights)
  # Faz uma escolha aleatória de um elemento com base em pesos
- shuffle_sum(lst)
  # Embaralha a lista e retorna a soma de seus elementos
- shuffle_product(lst)
  # Embaralha a lista e retorna o produto de seus elementos
- random_mean(lst, k, trials)
  # Calcula a média de múltiplas seleções aleatórias de k elementos
- random_cumsum(lst, k, trials)
  # Calcula a soma de k elementos selecionados aleatoriamente, repetindo por N testes

## CATEGORIA: INFORMACAO_QUANTICA (4 funções)
- density_matrix_purity(rho)
  # Pureza de uma matriz densidade: Tr(ρ²)
- von_neumann_entropy(rho)
  # Entropia de von Neumann: -Tr(ρ log ρ)
- quantum_fidelity(rho, sigma)
  # Fidelidade quântica entre dois estados
- concurrence_entanglement(rho)
  # Concorrência para medida de emaranhamento de 2 qubits

## CATEGORIA: MACHINE_LEARNING (8 funções)
- mse(y_true, y_pred)
  # Calcula o Erro Quadrático Médio (MSE)
- rmse(y_true, y_pred)
  # Calcula a Raiz do Erro Quadrático Médio (RMSE)
- mae(y_true, y_pred)
  # Calcula o Erro Absoluto Médio (MAE)
- r2(y_true, y_pred)
  # Calcula o coeficiente de determinação R²
- accuracy(y_true, y_pred)
  # Calcula a acurácia para tarefas de classificação
- f1(y_true, y_pred)
  # Calcula a pontuação F1 (macro-média)
- precision(y_true, y_pred)
  # Calcula a precisão (macro-média)
- recall(y_true, y_pred)
  # Calcula o recall (macro-média)

## CATEGORIA: MANIPULACAO_DADOS (4 funções)
- fill_missing_values(lst, strategy)
  # Preenche valores ausentes (np
- normalize_data(lst)
  # Normaliza os dados para o intervalo [0, 1]
- standardize_data(lst)
  # Padroniza os dados (média 0, desvio padrão 1)
- get_dummies(lst)
  # Converte uma lista de valores categóricos em variáveis dummy

## CATEGORIA: MATEMATICA_ESPECIAL (16 funções)
- gamma_transform(lst)
  # Aplica a função Gamma a cada elemento positivo da lista
- bessel_j_list(lst, n)
  # Calcula a função de Bessel de primeira espécie para uma lista
- euler_totient(lst)
  # Calcula a função totiente de Euler para cada elemento positivo
- sum_divisors(lst)
  # Calcula a soma dos divisores de cada elemento
- loggamma_func(x)
  # Calcula o logaritmo da função Gamma
- digamma_func(x)
  # Calcula a função Digamma
- bessel_y(n, x)
  # Calcula a função de Bessel de segunda espécie
- bessel_j0(x)
  # Função de Bessel de primeira espécie de ordem 0
- bessel_y0(x)
  # Função de Bessel de segunda espécie de ordem 0
- error_func(x)
  # Função de erro (erf)
- error_func_c(x)
  # Função de erro complementar (erfc)
- elliptic_j(u, m)
  # Funções elípticas de Jacobi (sn, cn, dn)
- legendre_p(n, x)
  # Polinômio de Legendre de ordem n
- chebyshev_t(n, x)
  # Polinômio de Chebyshev de primeira espécie de ordem n
- airy_ai(x)
  # Função Airy Ai
- airy_bi(x)
  # Função Airy Bi

## CATEGORIA: MODELAGEM_PREDITIVA (6 funções)
- linear_regression_predict(lst, steps)
  # Prediz o próximo valor de uma lista usando regressão linear
- poly_regression_predict(lst, degree, steps)
  # Prediz o próximo valor de uma lista usando regressão polinomial
- regression_on_frequency(lst, steps)
  # Aplica regressão linear na frequência cumulativa de uma lista
- linear_regression_coeffs(x, y)
  # Calcula os coeficientes de regressão linear (inclinação e interceptação)
- predict_linear(x, m, c)
  # Prediz valores usando uma equação de regressão linear
- regression_score(x, y)
  # Calcula a pontuação de ajuste de regressão linear (negativo do MSE)

## CATEGORIA: NUMEROS_ESPECIAIS (8 funções)
- fibonacci(n)
  # Retorna o n-ésimo número de Fibonacci
- lucas(n)
  # Retorna o n-ésimo número de Lucas
- catalan_number(n)
  # Retorna o n-ésimo número de Catalan
- bell_number(n)
  # Retorna o n-ésimo número de Bell
- partition_number(n)
  # Retorna o número de partições de n
- stirling2(n, k)
  # Retorna o número de Stirling de segunda espécie S(n, k)
- stirling1(n, k)
  # Retorna o número de Stirling de primeira espécie s(n, k)
- bernoulli_number(n)
  # Retorna o n-ésimo número de Bernoulli

## CATEGORIA: OTIMIZACAO_METAHEURISTICAS (3 funções)
- simulated_annealing(objective, bounds, max_iter, temp)
  # Algoritmo de simulated annealing para otimização
- particle_swarm_optimization(objective, bounds, n_particles, max_iter)
  # Otimização por enxame de partículas
- genetic_algorithm(objective, bounds, pop_size, generations)
  # Algoritmo genético simples

## CATEGORIA: PLOTS (7 funções)
- plot_histogram(data, title, bins, color)
  # Plota um histograma de uma lista de dados
- plot_scatter(x, y, title, color)
  # Plota um gráfico de dispersão de dois conjuntos de dados
- plot_boxplot(data, title)
  # Plota um boxplot para visualizar a distribuição e outliers
- plot_time_series(series, title, color)
  # Plota uma série temporal
- rolling_mean_plot(lst, window)
  # Plota a média móvel de uma lista
- cumulative_sum_plot(lst)
  # Plota a soma cumulativa de uma lista
- heatmap_pairs(lst)
  # Cria um mapa de calor para a frequência de pares

## CATEGORIA: PRECISAO (5 funções)
- mpmath_sqrt(x)
  # Calcula a raiz quadrada de x com alta precisão
- mpmath_log(x)
  # Calcula o logaritmo natural de x com alta precisão
- mpmath_sin(x)
  # Calcula o seno de x com alta precisão
- mpmath_prod_list(lst)
  # Calcula o produto dos elementos de uma lista com alta precisão
- mpmath_sum_list(lst)
  # Calcula a soma dos elementos de uma lista com alta precisão

## CATEGORIA: PROBABILIDADE (14 funções)
- poisson_pmf(k, mu)
  # Calcula a PMF da distribuição de Poisson
- poisson_cdf(k, mu)
  # Calcula a CDF da distribuição de Poisson
- poisson_var(mu)
  # Calcula a variância da distribuição de Poisson
- poisson_entropy(mu)
  # Calcula a entropia da distribuição de Poisson
- binomial_pmf(k, n, p)
  # Calcula a PMF da distribuição binomial
- binomial_cdf(k, n, p)
  # Calcula a CDF da distribuição binomial
- binomial_var(n, p)
  # Calcula a variância da distribuição binomial
- binomial_entropy(n, p)
  # Calcula a entropia da distribuição binomial
- normal_pdf(x, mu, sigma)
  # Calcula a PDF da distribuição normal
- normal_cdf(x, mu, sigma)
  # Calcula a CDF da distribuição normal
- normal_var(sigma)
  # Calcula a variância da distribuição normal
- normal_entropy(mu, sigma)
  # Calcula a entropia da distribuição normal
- exponential_pdf(x, lmbda)
  # Calcula a PDF da distribuição exponencial
- uniform_pdf(x, a, b)
  # Calcula a PDF da distribuição uniforme

## CATEGORIA: PROBABILIDADE_DISTRIBUICOES (3 funções)
- simulate_multinomial_prob(lst, probabilities, trials)
  # Simula uma distribuição multinomial
- simulate_dirichlet(alpha, size)
  # Simula uma distribuição de Dirichlet
- simulate_multivariate_wishart(df, scale, size)
  # Simula uma distribuição de Wishart multivariada (avançada)

## CATEGORIA: PROCESSAMENTO_SINAIS_AVANCADO (5 funções)
- wigner_ville_distribution(signal_data)
  # Distribuição de Wigner-Ville simplificada
- reassigned_spectrogram(signal_data, fs)
  # Espectrograma reassigned para melhor resolução tempo-frequência
- empirical_mode_decomposition(signal_data, num_imfs)
  # Decomposição Modal Empírica simplificada
- higuchi_fractal_dimension(signal_data, k_max)
  # Dimensão fractal de Higuchi para séries temporais
- sample_entropy(signal_data, m, r)
  # Entropia amostral para análise de complexidade

## CATEGORIA: PROCESSAMENTO_SINAL (24 funções)
- fft_real(lst)
  # Calcula a magnitude da FFT de uma lista
- fft_log(lst)
  # Calcula a FFT da lista transformada em log
- fft_sqrt(lst)
  # Calcula a FFT da raiz quadrada da lista
- fft_normalized(lst)
  # Calcula a FFT normalizada da lista
- fft_frequencies(n, sample_rate)
  # Retorna as frequências correspondentes à FFT
- apply_lowpass(lst, cutoff, order)
  # Aplica um filtro passa-baixa Butterworth
- apply_highpass(lst, cutoff, order)
  # Aplica um filtro passa-alta Butterworth
- apply_bandpass(lst, low, high, order)
  # Aplica um filtro passa-faixa Butterworth
- wavelet_decompose(lst, wavelet, level)
  # Decompõe uma lista em coeficientes de Wavelet (DWT)
- wavelet_reconstruct(coeffs, wavelet)
  # Reconstrói uma lista a partir de coeficientes de Wavelet
- dwt_approx(lst, wavelet)
  # Retorna apenas os coeficientes de aproximação da DWT
- dwt_detail(lst, wavelet)
  # Retorna os coeficientes de detalhe da DWT
- hilbert_transform(lst)
  # Calcula a Transformada de Hilbert (magnitude)
- savgol_smooth(lst, window, poly)
  # Aplica filtro de Savitzky-Golay para suavização
- stft_transform(lst, fs)
  # Aplica a Transformada de Fourier de Curto Prazo (STFT)
- istft_transform(Z, fs)
  # Reconstrói sinal a partir da STFT (ISTFT)
- welch_psd(lst, fs)
  # Calcula o Power Spectral Density pelo método de Welch
- periodogram_psd(lst, fs)
  # Calcula o Power Spectral Density pelo periodograma
- spectral_energy(lst)
  # Calcula a energia total do espectro
- spectral_entropy(lst)
  # Calcula a entropia espectral do sinal
- find_signal_peaks(lst)
  # Encontra os índices dos picos no sinal
- detect_cycle_length(lst)
  # Detecta o comprimento do ciclo repetitivo mais curto
- butter_lowpass(cutoff, fs, order)
  # Retorna coeficientes de filtro Butterworth passa-baixa
- filter_signal(b, a, x)
  # Filtra um sinal usando os coeficientes b e a

## CATEGORIA: SEQUENCIAS (7 funções)
- diff(lst)
  # Diferença entre elementos consecutivos (x₂ - x₁)
- diff_abs(lst)
  # Diferença absoluta entre elementos consecutivos
- ratio_consecutive(lst)
  # Razão simples entre elementos consecutivos (x₂ / x₁)
- rolling_sum(lst, window)
  # Soma em janela deslizante
- rolling_mean(lst, window)
  # Média em janela deslizante
- rolling_std(lst, window)
  # Desvio padrão em janela deslizante
- rank_array(lst)
  # Ranking dos elementos de uma lista

## CATEGORIA: SERIES_TEMPORAIS (9 funções)
- arima_predict(lst, order, steps)
- centered_moving_average(lst, window)
- ewma(lst, span)
- exp_weighted_mean(lst, alpha)
- cumulative_sum(lst)
- cumulative_product(lst)
- normalized_cumsum(lst)
- cumulative_max(lst)
- cumulative_min(lst)

## CATEGORIA: SIMULACAO (10 funções)
- sample_binomial(n, p, size)
  # Gera uma amostra de uma distribuição Binomial
- sample_poisson(lam, size)
  # Gera uma amostra de uma distribuição de Poisson
- sample_normal(mu, sigma, size)
  # Gera uma amostra de uma distribuição Normal
- monte_carlo_sum(target_sum, trials)
  # Calcula a probabilidade de atingir uma soma alvo em amostras aleatórias
- monte_carlo_even_ratio(trials)
  # Simula a proporção média de números pares em amostras aleatórias
- monte_carlo_prime_ratio(trials)
  # Simula a proporção média de números primos em amostras aleatórias
- monte_carlo_max(trials)
  # Simula os valores máximos de amostras aleatórias
- monte_carlo_min(trials)
  # Simula os valores mínimos de amostras aleatórias
- monte_carlo_multistep(lst, steps, trials)
  # Simulação Monte Carlo multi-passos, selecionando elementos aleatórios
- metropolis_hastings(target_func, start, iterations, proposal_std)
  # Geração de amostras MCMC usando o algoritmo Metropolis-Hastings

## CATEGORIA: SINAIS_NAO_LINEARES (4 funções)
- teager_kaiser_energy(signal_data)
  # Energia de Teager-Kaiser para sinais não-lineares
- higher_order_moments(signal_data, order)
  # Momentos de ordem superior deslizantes
- bispectral_analysis(signal_data)
  # Análise bispectral simplificada (transformada de Fourier 2D)
- empirical_wavelet_transform(signal_data, num_modes)
  # Transformada empírica de wavelet

## CATEGORIA: SISTEMAS_DINAMICOS (4 funções)
- rossler_attractor(a, b, c, steps)
  # Atractor de Rössler - sistema caótico
- lyapunov_spectrum(system_func, initial, steps)
  # Espectro de Lyapunov para sistemas dinâmicos
- recurrence_plot(series, threshold)
  # Plot de recorrência para análise de sistemas dinâmicos
- permutation_entropy(series, order, delay)
  # Entropia de permutação para análise de complexidade

## CATEGORIA: TEMPORAIS (7 funções)
- lag_series(lst, lag)
  # Calcula a diferença entre elementos com um certo atraso (lag)
- fft_magnitude(lst)
  # Calcula a magnitude da Transformada Rápida de Fourier (FFT)
- fft_phase(lst)
  # Calcula a fase da Transformada Rápida de Fourier (FFT)
- ifft_real(lst)
  # Calcula a Transformada Inversa de Fourier (IFFT) e retorna a parte real
- dominant_frequency(lst)
  # Encontra o índice da frequência dominante em uma lista
- autocorr(lst, lag)
  # Calcula a autocorrelação de uma lista em um determinado atraso
- autocorr_series(lst, max_lag)
  # Calcula a série de autocorrelação para múltiplos atrasos

## CATEGORIA: TEORIA_INFORMACAO (7 funções)
- shannon_entropy(lst)
  # Calcula a entropia de Shannon de uma distribuição de probabilidade
- normalized_entropy(lst)
  # Calcula a entropia de Shannon normalizada
- mutual_info(x, y)
  # Calcula a informação mútua entre duas listas
- normalized_mutual_info(x, y)
  # Calcula a informação mútua normalizada
- kl_divergence(p, q)
  # Calcula a divergência de Kullback-Leibler entre duas distribuições
- jensen_shannon(p, q)
  # Calcula a divergência de Jensen-Shannon entre duas distribuições
- gini_impurity(lst)
  # Calcula a impureza de Gini de uma distribuição

## CATEGORIA: TEORIA_MEDIDA (3 funções)
- lebesgue_integral_approx(f, domain, measure, partitions)
  # Integral de Lebesgue aproximada
- radon_nikodym_derivative_approx(measure1, measure2, points)
  # Derivada de Radon-Nikodym aproximada
- hausdorff_dimension_approx(points, scales)
  # Dimensão de Hausdorff aproximada de um conjunto

## CATEGORIA: TEORIA_NUMEROS (16 funções)
- euler_totient(n)
  # Calcula a função totiente de Euler
- factor_integer(n)
  # Fatora um número em seus fatores primos
- prime_factors(n)
  # Retorna os fatores primos únicos de um número
- prime_factor_count(n)
  # Retorna o número de fatores primos únicos de um número
- largest_prime_factor(n)
  # Retorna o maior fator primo de um número
- smallest_prime_factor(n)
  # Retorna o menor fator primo de um número
- gcd_list(lst)
  # Calcula o Máximo Divisor Comum (MDC) de uma lista de números
- lcm_list(lst)
  # Calcula o Mínimo Múltiplo Comum (MMC) de uma lista de números
- check_prime(n)
  # Verifica se um número é primo
- count_primes_upto(n)
  # Conta o número de primos até n
- next_prime_num(n)
  # Encontra o próximo número primo após n
- prev_prime_num(n)
  # Encontra o número primo anterior a n
- generate_primes(n)
  # Gera uma lista de primos até n
- fibonacci_num(n)
  # Retorna o n-ésimo número de Fibonacci
- lucas_num(n)
  # Retorna o n-ésimo número de Lucas
- catalan_num(n)
  # Retorna o n-ésimo número de Catalan

## CATEGORIA: TEORIA_NUMEROS_AVANCADA (13 funções)
- divisor_sigma(n, k)
  # Função sigma σ_k(n) - soma das k-ésimas potências dos divisores
- euler_phi(n)
  # Função totiente de Euler φ(n)
- mobius_function(n)
  # Função Möbius μ(n)
- liouville_function(n)
  # Função de Liouville λ(n)
- perfect_numbers_up_to(limit)
  # Números perfeitos até o limite
- amicable_numbers_up_to(limit)
  # Pares de números amigáveis
- abundant_numbers(lst)
  # Números abundantes na lista
- deficient_numbers(lst)
  # Números deficientes na lista
- partition_function(n)
  # Função de partição p(n)
- compositions_count(n, k)
  # Número de composições de n em k partes
- quadratic_residues(p)
  # Resíduos quadráticos módulo p (primo)
- legendre_symbol(a, p)
  # Símbolo de Legendre (a/p)
- jacobi_symbol(a, n)
  # Símbolo de Jacobi (a/n)

## CATEGORIA: TEORIA_NUMEROS_COMPUTACIONAL (4 funções)
- pollard_rho_factorization(n, max_iter)
  # Algoritmo ρ de Pollard para fatoração
- baby_step_giant_step(a, b, p)
  # Algoritmo baby-step giant-step para logaritmo discreto
- chinese_remainder_theorem(residues, moduli)
  # Teorema Chinês do Resto
- miller_rabin_primality(n, k)
  # Teste de primalidade Miller-Rabin

## CATEGORIA: TRANSFORMACOES (25 funções)
- floor_div(a, b)
  # Calcula a divisão inteira de dois números (floor division)
- ceil_div(a, b)
  # Calcula a divisão inteira arredondada para cima (ceil division)
- mod_inverse(a, k)
  # Calcula o inverso modular de 'a' mod 'k' (se existir)
- floor_val(a)
  # Retorna o maior inteiro menor ou igual a 'a'
- ceil_val(a)
  # Retorna o menor inteiro maior ou igual a 'a'
- sqrt_transform(lst)
  # Transformação de raiz quadrada
- cbrt_transform(lst)
  # Transformação de raiz cúbica
- square_transform(lst)
  # Transformação de potência ao quadrado
- cube_transform(lst)
  # Transformação de potência ao cubo
- exp_transform(lst)
  # Transformação exponencial
- reciprocal_transform(lst)
  # Transformação recíproca (1/x)
- log_transform(lst)
  # Transformação logarítmica (base e)
- log10_transform(lst)
  # Transformação logarítmica (base 10)
- log_normalize(lst)
  # Normalização com transformação logarítmica
- sqrt_log_transform(lst)
  # Transformação combinada: raiz da transformação logarítmica
- sin_transform(lst)
  # Transformação seno
- cos_transform(lst)
  # Transformação cosseno
- tan_transform(lst)
  # Transformação tangente
- arcsin_transform(lst)
  # Transformação arcoseno (normalizada pelo valor máximo)
- arccos_transform(lst)
  # Transformação arccoseno (normalizada pelo valor máximo)
- arctan_transform(lst)
  # Transformação arctangente
- centered_sin(lst)
  # Transformação seno centrada na média
- mod_transform(lst, m)
  # Transformação de módulo (x % m)
- minmax_normalize(lst)
  # Normalização Min-Max
- zscore_normalize(lst)
  # Normalização Z-Score

## CATEGORIA: WAVELETS (5 funções)
- wavelet_dwt(data, wavelet)
  # Aplica a Transformada Discreta de Wavelet (DWT) de nível 1
- wavelet_idwt(cA, cD, wavelet)
  # Aplica a Transformada Discreta de Wavelet Inversa (IDWT) de nível 1
- wavelet_wavedec(data, level, wavelet)
  # Aplica a decomposição de wavelet multinível
- wavelet_waverec(coeffs, wavelet)
  # Reconstrói um sinal a partir dos coeficientes de wavelet
- wavelet_energy(data, wavelet)
  # Calcula a energia total de um sinal em diferentes níveis de wavelet


## ⚠️ FUNÇÕES DUPLICADAS
- euler_totient em lib/funcoes_limpas/matematica_especial.py
- catalan_number em lib/funcoes_limpas/combinatoria_avancada_1.py
