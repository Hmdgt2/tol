import os
import re
import json
import sys
from datetime import datetime

# CONFIGURA√á√ïES
LISTA_FUNCOES_JSON = "relatorios/lista_funcoes.json"
WRAPPER_SCRIPT = "scripts/gerar_wrappers_funcoes.py"
RELATORIO_PATH = "relatorios/atualizacao_categorias.txt"

os.makedirs(os.path.dirname(RELATORIO_PATH), exist_ok=True)

def carregar_funcoes_do_json():
    """Carrega as fun√ß√µes e categorias do relat√≥rio JSON."""
    if not os.path.exists(LISTA_FUNCOES_JSON):
        print(f"‚ùå Arquivo {LISTA_FUNCOES_JSON} n√£o encontrado.")
        print("üí° Execute primeiro: python scripts/analisador_funcoes.py")
        return {}, []
    
    with open(LISTA_FUNCOES_JSON, "r", encoding="utf-8") as f:
        dados = json.load(f)
    
    categorias = dados.get("categorias", {})
    duplicados = dados.get("duplicados", [])
    
    print(f"üìÅ Carregadas {len(categorias)} categorias do JSON")
    return categorias, duplicados

def carregar_mapa_atual(script_path):
    """Carrega o FUNCAO_CATEGORIA_MAP atual do script."""
    try:
        with open(script_path, "r", encoding="utf-8") as f:
            content = f.read()
        
        # Encontrar FUNCAO_CATEGORIA_MAP usando regex
        pattern = r"FUNCAO_CATEGORIA_MAP\s*=\s*\{([^}]+)\}"
        match = re.search(pattern, content, re.DOTALL)
        
        if not match:
            print("‚ùå N√£o foi poss√≠vel encontrar FUNCAO_CATEGORIA_MAP")
            return {}
        
        mapa_str = "{" + match.group(1) + "}"
        
        # Converter string para dicion√°rio com eval seguro
        mapa_atual = eval(mapa_str)
        return mapa_atual
        
    except FileNotFoundError:
        print(f"‚ö†Ô∏è  Arquivo {script_path} n√£o encontrado. Criando mapa vazio.")
        return {}
    except Exception as e:
        print(f"‚ùå Erro ao carregar mapa atual: {e}")
        return {}

def gerar_sugestoes_categoria(categoria, funcoes):
    """Gera sugest√µes inteligentes para nova categoria."""
    nomes_funcoes = [f["nome"] for f in funcoes]
    
    # Mapeamento de sugest√µes baseado no nome da categoria
    sugestoes_map = {
        "estatistica_nao_parametrica": ("NonParametricStatsWrapper", "Testes estat√≠sticos n√£o param√©tricos", "An√°lise robusta sem suposi√ß√µes distribucionais"),
        "combinatoria": ("CombinatoricsWrapper", "C√°lculos combinat√≥rios e permuta√ß√µes", "An√°lise de combina√ß√µes e arranjos"),
        "probabilidade_distribuicoes": ("ProbabilityWrapper", "Simula√ß√£o de distribui√ß√µes probabil√≠sticas", "Gera√ß√£o de dados sint√©ticos e modelagem"),
        "precisao": ("PrecisionWrapper", "C√°lculos com alta precis√£o num√©rica", "Opera√ß√µes matem√°ticas de alta precis√£o"),
        "analise_padroes": ("PatternAnalysisWrapper", "An√°lise e detec√ß√£o de padr√µes", "Identifica√ß√£o de padr√µes complexos em dados"),
        "estatisticas": ("BasicStatsWrapper", "Estat√≠sticas descritivas b√°sicas", "C√°lculos estat√≠sticos fundamentais"),
        "sequencias": ("SequenceAnalysisWrapper", "An√°lise de sequ√™ncias e s√©ries", "Processamento e an√°lise de dados sequenciais"),
        "algebra_simbolica": ("SymbolicMathWrapper", "Manipula√ß√£o alg√©brica simb√≥lica", "C√°lculos simb√≥licos e algebra avan√ßada"),
        "manipulacao_dados": ("DataManipulationWrapper", "Transforma√ß√£o e prepara√ß√£o de dados", "Pr√©-processamento e manipula√ß√£o de datasets"),
        "numeros_especiais": ("SpecialNumbersWrapper", "Sequ√™ncias num√©ricas especiais", "C√°lculos com sequ√™ncias matem√°ticas especiais"),
        "transformacoes": ("TransformationWrapper", "Transforma√ß√µes matem√°ticas de dados", "Aplica√ß√£o de transforma√ß√µes a conjuntos de dados"),
        "deteccao_anomalias": ("AnomalyDetectionWrapper", "Detec√ß√£o de outliers e anomalias", "Identifica√ß√£o de valores at√≠picos"),
        "series_temporais": ("TimeSeriesWrapper", "An√°lise de s√©ries temporais", "Processamento e modelagem temporal"),
        "probabilidade": ("ProbabilityTheoryWrapper", "Teoria da probabilidade", "C√°lculos probabil√≠sticos e distribui√ß√µes"),
        "funcoes_especiais": ("SpecialFunctionsWrapper", "Fun√ß√µes matem√°ticas especiais", "C√°lculos com fun√ß√µes matem√°ticas avan√ßadas"),
        "wavelets": ("WaveletAnalysisWrapper", "An√°lise wavelet", "Decomposi√ß√£o multirresolu√ß√£o de sinais"),
        "teoria_informacao": ("InformationTheoryWrapper", "Teoria da informa√ß√£o", "C√°lculos de entropia e informa√ß√£o m√∫tua"),
        "processamento_sinal": ("SignalProcessingWrapper", "Processamento de sinal", "An√°lise e transforma√ß√£o de sinais"),
        "algoritmos_grafos": ("GraphAlgorithmWrapper", "Algoritmos de grafos", "Execu√ß√£o de algoritmos em estruturas de grafos"),
        "grafos": ("GraphAnalysisWrapper", "An√°lise de grafos", "M√©tricas e propriedades de grafos"),
        "estatistica_multivariada": ("MultivariateStatsWrapper", "Estat√≠stica multivariada", "An√°lise de dados multidimensionais"),
        "ia_heuristica": ("HeuristicMLWrapper", "Heur√≠sticas e algoritmos de IA", "Otimiza√ß√£o e algoritmos inteligentes"),
        "machine_learning": ("MLMetricsWrapper", "M√©tricas de machine learning", "Avalia√ß√£o de modelos de ML"),
        "simulacao": ("SimulationWrapper", "Simula√ß√£o e Monte Carlo", "M√©todos de simula√ß√£o estat√≠stica"),
        "aritmetica": ("ArithmeticWrapper", "Opera√ß√µes aritm√©ticas", "C√°lculos matem√°ticos b√°sicos"),
        "analise_numerica": ("NumericalAnalysisWrapper", "An√°lise num√©rica", "M√©todos num√©ricos e computacionais"),
        "exploracao": ("ExplorationWrapper", "Explora√ß√£o de dados", "An√°lise explorat√≥ria e descoberta"),
        "plots": ("VisualizationWrapper", "Visualiza√ß√£o de dados", "Gera√ß√£o de gr√°ficos e visualiza√ß√µes"),
        "modelagem_preditiva": ("PredictiveModelingWrapper", "Modelagem preditiva", "Algoritmos de previs√£o e regress√£o"),
        "geometria": ("GeometryWrapper", "Geometria e dist√¢ncias", "C√°lculos geom√©tricos e m√©tricas"),
        "criptografia": ("CryptographyWrapper", "Criptografia e seguran√ßa", "Algoritmos criptogr√°ficos"),
        "analise_primos": ("PrimeAnalysisWrapper", "An√°lise de n√∫meros primos", "Propriedades e caracter√≠sticas de primos"),
        "teoria_numeros": ("NumberTheoryWrapper", "Teoria dos n√∫meros", "Propriedades avan√ßadas de n√∫meros"),
        "matematica_especial": ("SpecialMathWrapper", "Matem√°tica especializada", "Fun√ß√µes e conceitos matem√°ticos avan√ßados"),
        "conjuntos": ("SetTheoryWrapper", "Teoria dos conjuntos", "Opera√ß√µes e an√°lise de conjuntos"),
        "temporais": ("TemporalAnalysisWrapper", "An√°lise temporal", "Processamento de dados temporais")
    }
    
    # Verificar se temos uma sugest√£o pr√©-definida
    if categoria in sugestoes_map:
        return sugestoes_map[categoria]
    
    # Caso contr√°rio, gerar sugest√£o gen√©rica
    wrapper_name = f"{categoria.title().replace('_', '')}Wrapper"
    objetivo = f"Processar fun√ß√µes de {categoria}"
    finalidade = "Feature extraction para pipeline de IA"
    
    return wrapper_name, objetivo, finalidade

def atualizar_script_wrappers(script_path, novas_categorias, categorias_removidas, categorias_detectadas):
    """Atualiza o script de wrappers com novas categorias."""
    
    # Se o arquivo n√£o existe, criar um b√°sico
    if not os.path.exists(script_path):
        print(f"‚ö†Ô∏è  Arquivo {script_path} n√£o encontrado. Criando novo...")
        conteudo_base = '''import os
import ast

# Mapear tipo de m√≥dulo para classe de wrapper, objetivo e finalidade
FUNCAO_CATEGORIA_MAP = {
}

BASE_DIR = "lib/funcoes_analiticas"
WRAPPER_MODULE_PATH = "lib/funcoes_wrappers_auto.py"

def categoria_objetivo_finalidade(caminho):
    modulo = caminho.split("/")[-2]
    return FUNCAO_CATEGORIA_MAP.get(modulo, ("GenericFeatureWrapper", "Gen√©rico", "Transforma√ß√£o gen√©rica para integra√ß√£o universal"))

def extrair_funcoes(base_dir):
    resultados = []
    for root, _, files in os.walk(base_dir):
        for file in files:
            if file.endswith(".py"):
                caminho = os.path.join(root, file)
                modulo = os.path.basename(caminho).replace(".py", "")
                try:
                    with open(caminho, "r", encoding="utf-8") as f:
                        tree = ast.parse(f.read(), filename=caminho)
                        for node in tree.body:
                            if isinstance(node, ast.FunctionDef):
                                nome = node.name
                                args = [a.arg for a in node.args.args]
                                docstring = ast.get_docstring(node) or ""
                                resultados.append({
                                    "nome": nome,
                                    "caminho": caminho,
                                    "modulo": modulo,
                                    "args": args,
                                    "docstring": docstring
                                })
                except Exception as e:
                    print(f"Erro ao processar {caminho}: {e}")
    return resultados

def gerar_wrappers(funcoes, destino_path):
    # Primeiro, agrupar por classe de wrapper
    wrappers_dict = {}
    metadados_dict = {}
    for func in funcoes:
        wrapper_class, objetivo, finalidade = categoria_objetivo_finalidade(func["caminho"])
        if wrapper_class not in wrappers_dict:
            wrappers_dict[wrapper_class] = []
            metadados_dict[wrapper_class] = (objetivo, finalidade)
        wrappers_dict[wrapper_class].append(func)

    # Gerar arquivo de wrappers
    with open(destino_path, "w", encoding="utf-8") as f:
        f.write("# Wrappers autom√°ticos para fun√ß√µes anal√≠ticas\\n")
        f.write("# Cada wrapper inclui objetivo e finalidade, facilitando integra√ß√£o universal\\n\\n")

        for wrapper_class, funclist in wrappers_dict.items():
            objetivo, finalidade = metadados_dict[wrapper_class]
            f.write(f"class {wrapper_class}:\\n")
            f.write(f'    """\\n    Objetivo: {objetivo}\\n    Finalidade no pipeline: {finalidade}\\n    """\\n\\n')
            # Wrapper universal adaptativo (opcional)
            f.write(f"    @staticmethod\\n")
            f.write(f"    def apply_function(func, data, *args, **kwargs):\\n")
            f.write(f"        \\"\\"\\"\\n        Aplica fun√ß√£o a dados, adaptando tipo de retorno para integra√ß√£o universal.\\n        \\"\\"\\"\\n")
            f.write(f"        result = func(data, *args, **kwargs)\\n")
            f.write(f"        if isinstance(result, list):\\n")
            f.write(f"            return result[:5] if len(result) > 5 else result\\n")
            f.write(f"        elif isinstance(result, dict):\\n")
            f.write(f"            return list(result.values())[:5]\\n")
            f.write(f"        elif isinstance(result, (int, float)):\\n")
            f.write(f"            return [result]\\n")
            f.write(f"        elif hasattr(result, 'shape'):\\n")
            f.write(f"            try:\\n")
            f.write(f"                return result.flatten().tolist()[:5]\\n")
            f.write(f"            except Exception:\\n")
            f.write(f"                return [float(result)]\\n")
            f.write(f"        return result\\n\\n")
            # Gerar wrapper para cada fun√ß√£o
            for func in funclist:
                args_str = ", ".join(func["args"])
                args_pass = ", ".join(func["args"])
                doc = func["docstring"].replace('\\n', '\\n        ')
                f.write(f"    @staticmethod\\n")
                f.write(f"    def {func['nome']}({args_str}):\\n")
                if doc:
                    f.write(f'        """{doc}"""\\n')
                f.write(f"        # Chamada original + adapta√ß√£o universal\\n")
                f.write(f"        from lib.funcoes_analiticas.{func['modulo']} import {func['nome']}\\n")
                f.write(f"        return {wrapper_class}.apply_function({func['nome']}, {args_pass})\\n\\n")
            f.write("\\n")
    print(f"‚úÖ Wrappers gerados em: {destino_path}")

if __name__ == "__main__":
    funcoes = extrair_funcoes(BASE_DIR)
    gerar_wrappers(funcoes, WRAPPER_MODULE_PATH)
'''
        with open(script_path, "w", encoding="utf-8") as f:
            f.write(conteudo_base)
    
    with open(script_path, "r", encoding="utf-8") as f:
        content = f.read()
    
    # Carregar mapa atual
    mapa_atual = carregar_mapa_atual(script_path)
    
    # Adicionar novas categorias
    for categoria in novas_categorias:
        wrapper_name, objetivo, finalidade = gerar_sugestoes_categoria(
            categoria, categorias_detectadas[categoria]
        )
        mapa_atual[categoria] = (wrapper_name, objetivo, finalidade)
        print(f"   ‚úÖ Adicionada: {categoria} -> {wrapper_name}")
    
    # Remover categorias exclu√≠das
    for categoria in categorias_removidas:
        if categoria in mapa_atual:
            del mapa_atual[categoria]
            print(f"   ‚ùå Removida: {categoria}")
    
    # Gerar novo conte√∫do do mapa
    novo_mapa_str = "FUNCAO_CATEGORIA_MAP = {\n"
    for cat, (wrapper, obj, final) in sorted(mapa_atual.items()):
        novo_mapa_str += f'    "{cat}": ("{wrapper}", "{obj}", "{final}"),\n'
    novo_mapa_str += "}"
    
    # Substituir no conte√∫do
    pattern = r"FUNCAO_CATEGORIA_MAP\s*=\s*\{[^}]+\}"
    if re.search(pattern, content, re.DOTALL):
        novo_content = re.sub(pattern, novo_mapa_str, content, flags=re.DOTALL)
    else:
        # Se n√£o encontrar, adicionar ap√≥s imports
        novo_content = content.replace("FUNCAO_CATEGORIA_MAP = {}", novo_mapa_str)
    
    # Escrever arquivo atualizado
    with open(script_path, "w", encoding="utf-8") as f:
        f.write(novo_content)
    
    return len(novas_categorias), len(categorias_removidas)

def gerar_relatorio(novas_categorias, categorias_removidas, duplicados, categorias_detectadas):
    """Gera relat√≥rio detalhado da atualiza√ß√£o."""
    
    with open(RELATORIO_PATH, "w", encoding="utf-8") as f:
        f.write("# RELAT√ìRIO DE ATUALIZA√á√ÉO DE CATEGORIAS\n")
        f.write(f"# Gerado em: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write("=" * 50 + "\n\n")
        
        f.write("## üìä ESTAT√çSTICAS GERAIS\n")
        f.write(f"- Total de categorias detectadas: {len(categorias_detectadas)}\n")
        f.write(f"- Novas categorias adicionadas: {len(novas_categorias)}\n")
        f.write(f"- Categorias removidas: {len(categorias_removidas)}\n")
        f.write(f"- Fun√ß√µes duplicadas: {len(duplicados)}\n\n")
        
        if novas_categorias:
            f.write("## üÜï NOVAS CATEGORIAS ADICIONADAS\n")
            for cat in novas_categorias:
                wrapper_name, objetivo, finalidade = gerar_sugestoes_categoria(cat, categorias_detectadas[cat])
                f.write(f"### {cat}\n")
                f.write(f"- Wrapper: {wrapper_name}\n")
                f.write(f"- Objetivo: {objetivo}\n")
                f.write(f"- Finalidade: {finalidade}\n")
                f.write(f"- Fun√ß√µes: {len(categorias_detectadas[cat])}\n")
                for func in categorias_detectadas[cat][:5]:  # Mostrar apenas 5 primeiras
                    f.write(f"  - {func['nome']}: {func['args']}\n")
                if len(categorias_detectadas[cat]) > 5:
                    f.write(f"  - ... e {len(categorias_detectadas[cat]) - 5} mais\n")
                f.write("\n")
        
        if categorias_removidas:
            f.write("## üóëÔ∏è CATEGORIAS REMOVIDAS\n")
            for cat in categorias_removidas:
                f.write(f"- {cat}\n")
        
        if duplicados:
            f.write("## ‚ö†Ô∏è FUN√á√ïES DUPLICADAS (REVISAR)\n")
            for dup in duplicados[:10]:  # Mostrar apenas 10 primeiras
                f.write(f"- {dup['nome']} em {dup['caminho']} (categoria: {dup['categoria']})\n")
            if len(duplicados) > 10:
                f.write(f"- ... e {len(duplicados) - 10} mais duplicados\n")

def main():
    """Executa o pipeline completo de atualiza√ß√£o."""
    
    print("üîÑ INICIANDO FASE 2: ATUALIZA√á√ÉO DE CATEGORIAS...")
    
    # 1. Carregar fun√ß√µes do JSON gerado pelo analisador
    print("üìÅ Carregando fun√ß√µes do relat√≥rio JSON...")
    categorias_detectadas, duplicados = carregar_funcoes_do_json()
    
    if not categorias_detectadas:
        print("üí• N√£o foi poss√≠vel carregar as categorias. Pipeline interrompido.")
        return False
    
    # 2. Carregar categorias atuais do script
    print("üìã Carregando categorias atuais...")
    mapa_atual = carregar_mapa_atual(WRAPPER_SCRIPT)
    categorias_atuais = set(mapa_atual.keys())
    categorias_detectadas_set = set(categorias_detectadas.keys())
    
    # 3. Identificar mudan√ßas
    novas_categorias = categorias_detectadas_set - categorias_atuais
    categorias_removidas = categorias_atuais - categorias_detectadas_set
    
    print(f"üìä DETECTADAS: {len(categorias_detectadas_set)} categorias")
    print(f"üÜï NOVAS: {len(novas_categorias)} categorias")
    print(f"üóëÔ∏è REMOVIDAS: {len(categorias_removidas)} categorias")
    print(f"‚ö†Ô∏è DUPLICADOS: {len(duplicados)} fun√ß√µes")
    
    # Listar categorias detectadas
    print("\nüìÅ Categorias detectadas:")
    for cat in sorted(categorias_detectadas.keys()):
        print(f"  - {cat}: {len(categorias_detectadas[cat])} fun√ß√µes")
    
    # 4. Atualizar se necess√°rio
    atualizacao_realizada = False
    if novas_categorias or categorias_removidas:
        print("\nüîÑ ATUALIZANDO SCRIPT DE WRAPPERS...")
        novas_count, removidas_count = atualizar_script_wrappers(
            WRAPPER_SCRIPT, novas_categorias, categorias_removidas, categorias_detectadas
        )
        
        # 5. Gerar relat√≥rio
        print("üìÑ GERANDO RELAT√ìRIO...")
        gerar_relatorio(novas_categorias, categorias_removidas, duplicados, categorias_detectadas)
        
        print(f"\n‚úÖ ATUALIZA√á√ÉO CONCLU√çDA!")
        print(f"   ‚ûï {novas_count} novas categorias adicionadas")
        print(f"   ‚ûñ {removidas_count} categorias removidas") 
        print(f"   üìä Relat√≥rio salvo em: {RELATORIO_PATH}")
        
        atualizacao_realizada = True
        
    else:
        print("‚úÖ Nenhuma atualiza√ß√£o necess√°ria - todas as categorias est√£o sincronizadas")
    
    if duplicados:
        print(f"\n‚ö†Ô∏è  ATEN√á√ÉO: {len(duplicados)} fun√ß√µes duplicadas encontradas")
        print("   Revise o relat√≥rio para corrigir duplica√ß√µes")
    
    # VERIFICA√á√ÉO FINAL - Para o GitHub Actions
    mapa_final = carregar_mapa_atual(WRAPPER_SCRIPT)
    if (atualizacao_realizada and len(mapa_final) > 0) or (not atualizacao_realizada):
        print("üéØ FASE 2 CONCLU√çDA - Categorias atualizadas/prontas para commit")
        return True
    else:
        print("‚ùå FALHA - Categorias n√£o foram atualizadas corretamente")
        return False

if __name__ == "__main__":
    try:
        success = main()
        sys.exit(0 if success else 1)
    except Exception as e:
        print(f"üí• Erro no atualizador: {e}")
        sys.exit(1)
