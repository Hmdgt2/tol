#!/usr/bin/env python3
"""
GERADOR DE UNIVERSAL WRAPPER
Gera wrapper √∫nico a partir dos wrappers por categoria gerados anteriormente
"""

import os
import re
import ast
from datetime import datetime

def gerar_universal_wrapper():
    """Gera UniversalWrapper √∫nico baseado nos wrappers por categoria."""
    
    print("üåê Iniciando gera√ß√£o do UniversalWrapper...")
    
    # Caminhos dos arquivos
    wrappers_file = "lib/funcoes_wrappers_auto.py"
    output_file = "lib/universal_wrapper.py"
    
    if not os.path.exists(wrappers_file):
        print(f"‚ùå Arquivo de wrappers n√£o encontrado: {wrappers_file}")
        print("üí° Execute primeiro: python scripts/gerar_wrappers_funcoes.py")
        return False
    
    # Ler wrappers gerados
    with open(wrappers_file, "r", encoding="utf-8") as f:
        wrappers_content = f.read()
    
    # Extrair todas as classes e m√©todos
    classes = re.findall(r'class (\w+Wrapper):.*?(?=class|\Z)', wrappers_content, re.DOTALL)
    
    universal_methods = []
    imports_set = set()
    total_funcoes = 0
    
    for class_block in classes:
        class_match = re.match(r'class (\w+Wrapper)', class_block)
        if not class_match:
            continue
            
        class_name = class_match.group(1)
        imports_set.add(class_name)
        
        # Extrair m√©todos usando AST para maior precis√£o
        try:
            tree = ast.parse(class_block)
            for node in tree.body:
                if isinstance(node, ast.ClassDef):
                    for item in node.body:
                        if isinstance(item, ast.FunctionDef) and not item.name.startswith('_'):
                            # Encontrar a linha de return no c√≥digo original
                            method_code = None
                            lines = class_block.split('\n')
                            for i, line in enumerate(lines):
                                if f"def {item.name}(" in line:
                                    # Encontrar o bloco do m√©todo
                                    j = i
                                    while j < len(lines) and (lines[j].strip() or j == i):
                                        if "return" in lines[j] and class_name in lines[j]:
                                            method_code = lines[j]
                                            break
                                        j += 1
                                    break
                            
                            if method_code:
                                # Criar m√©todo no UniversalWrapper
                                method_template = f'''
    @staticmethod
    def {item.name}(*args, **kwargs):
        """M√©todo universal para {item.name}"""
        from lib.funcoes_wrappers_auto import {class_name}
        return {class_name}.{item.name}(*args, **kwargs)
'''
                                universal_methods.append(method_template)
                                total_funcoes += 1
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao processar {class_name}: {e}")
            continue
    
    # Gerar conte√∫do do UniversalWrapper
    template = f'''"""
UNIVERSAL WRAPPER - Interface √önica para Todas as Fun√ß√µes
================================================================
Gerado automaticamente em: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Total de fun√ß√µes: {total_funcoes}

‚ö†Ô∏è N√ÉO EDITAR MANUALMENTE - Este arquivo √© gerado automaticamente
   Qualquer altera√ß√£o ser√° sobrescrita na pr√≥xima execu√ß√£o do pipeline.

Fornece acesso unificado a todas as fun√ß√µes atrav√©s de uma interface consistente.
Ideal para algoritmos gen√©ticos e sistemas de ML que precisam compor heur√≠sticas.
"""

import numpy as np
from typing import List, Any

class UniversalWrapper:
    """
    Wrapper √∫nico com acesso a todas as fun√ß√µes anal√≠ticas.
    
    Objetivo: Interface padronizada para composi√ß√£o de heur√≠sticas
    Finalidade: Permitir combina√ß√£o livre de fun√ß√µes em algoritmos gen√©ticos/ML
    
    Caracter√≠sticas:
    - Todas as fun√ß√µes retornam List[float] padronizada
    - Tratamento autom√°tico de erros
    - Interface consistente para pipeline de IA
    - {total_funcoes} fun√ß√µes dispon√≠veis
    """
    
    # Importa√ß√µes din√¢micas de todos os wrappers
'''
    
    # Adicionar imports
    imports_code = "\n".join([f"from lib.funcoes_wrappers_auto import {cls}" for cls in sorted(imports_set)])
    
    # Adicionar m√©todos
    methods_code = "\n".join(universal_methods)
    
    # Adicionar m√©todos utilit√°rios
    util_methods = f'''
    
    @staticmethod
    def get_available_functions():
        """Retorna lista de todas as fun√ß√µes dispon√≠veis."""
        return [method for method in dir(UniversalWrapper) 
                if not method.startswith('_') and callable(getattr(UniversalWrapper, method))]
    
    @staticmethod
    def get_function_count():
        """Retorna o n√∫mero total de fun√ß√µes dispon√≠veis."""
        return {total_funcoes}
    
    @staticmethod
    def get_function_info(func_name):
        """Retorna informa√ß√µes sobre uma fun√ß√£o espec√≠fica."""
        if hasattr(UniversalWrapper, func_name) and callable(getattr(UniversalWrapper, func_name)):
            return f"Fun√ß√£o {{func_name}} dispon√≠vel no UniversalWrapper"
        else:
            return f"Fun√ß√£o {{func_name}} n√£o encontrada"

if __name__ == "__main__":
    # Teste b√°sico
    print(f"üîß UniversalWrapper carregado com {{UniversalWrapper.get_function_count()}} fun√ß√µes")
    print("‚úÖ UniversalWrapper pronto para uso no pipeline!")
'''
    
    # Conte√∫do final
    final_content = template + imports_code + "\n" + methods_code + util_methods
    
    # Garantir que o diret√≥rio existe
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    
    # Escrever arquivo
    with open(output_file, "w", encoding="utf-8") as f:
        f.write(final_content)
    
    print(f"‚úÖ UniversalWrapper gerado: {output_file}")
    print(f"üìä Total de fun√ß√µes inclu√≠das: {total_funcoes}")
    print(f"üì¶ Wrappers importados: {len(imports_set)}")
    
    return True

if __name__ == "__main__":
    success = gerar_universal_wrapper()
    if success:
        print("üéØ Pr√≥ximo passo: Implementar gerador_logicas.py")
    else:
        print("üí• Falha na gera√ß√£o do UniversalWrapper")
        sys.exit(1)
